name: "Check file with Webhook"
description: "Check file for expected changes and send content to a webhook."
inputs:
  step:
    description: "Step document file to send."
    required: true
  submission:
    description: "Submission file to send."
    required: true
  solution:
    description: "Solution file to send."
    required: true
  webhook:
    description: "URL of the webhook."
    required: true
  authtoken:
    description: "Auth token for Twilio authentication."
    required: true
  accountsid:
    description: "Account SID for Twilio authentication."
    required: true
outputs:
  assessment:
    description: "True if the solution is correct"
  reason:
    description: "Reason for assessment"
runs:
  using: composite
  steps:
  - shell: bash
    env:
      STEPFILE: ${{ inputs.step }}
      SUBMISSIONFILE: ${{ inputs.submission }}
      SOLUTIONFILE: ${{ inputs.solution }}
      WEBHOOKURL: ${{ inputs.webhook }}
      AUTH_TOKEN: ${{ inputs.authtoken }}
      ACCOUNT_SID: ${{ inputs.accountsid }}
      GITHUB_USER_EMAIL: ${{ github.actor }}
    run: |
      echo "Checking that all required environment variables are set"

      # Verify required files exist
      for file in "$STEPFILE" "$SUBMISSIONFILE" "$SOLUTIONFILE"; do
        if [ ! -f "$file" ]; then
          echo "❌ Error: File $file does not exist"
          exit 1
        fi
      done

      for var in WEBHOOKURL AUTH_TOKEN ACCOUNT_SID; do
        if [ -z "${!var}" ]; then
          echo "❌ Error: $var is unset or empty"
          exit 1
        fi
      done

      # Function to clean file content
      clean_content() {
        if [ -f "$1" ]; then
          # Read the content, remove carriage returns and excess spaces, and escape quotes
          tr -d '\r\n' < "$1" | tr -s ' ' | sed 's/"/\\"/g'
        else
          echo "⚠️ File $1 not found"
        fi
      }

      # Read and clean file contents
      echo "Reading and formatting file contents..."
      step_content=$(clean_content "$STEPFILE")
      solution_content=$(clean_content "$SOLUTIONFILE")
      submission_content=$(clean_content "$SUBMISSIONFILE")

      uuid=$(uuidgen)
      ASSESSMENT_CONTENT="Instructions_${uuid}: ${step_content} Solution_${uuid}: ${solution_content} Submission_${uuid}: ${submission_content}"

      # Create the JSON payload, correctly escaping special characters
      JSON_PAYLOAD=$(printf '{"identity": "email:%s", "session_id": "mysession", "body": "%s"}' \
        "${GITHUB_USER_EMAIL}" \
        "${ASSESSMENT_CONTENT}")

      echo "Sending request to $WEBHOOKURL"

      # Store the curl command in a variable for debugging
      CURL_COMMAND="curl -s -w \"\n%{http_code}\" -X POST \"$WEBHOOKURL\" \
        -H \"Content-Type: application/json\" \
        -d '$JSON_PAYLOAD' \
        -u \"$ACCOUNT_SID:$AUTH_TOKEN\""

      # Echo the curl command for debugging
      echo "Running the following cURL command:"
      echo "$CURL_COMMAND"

      # Execute the stored curl command and capture the response
      RESPONSE=$(eval "$CURL_COMMAND")

      # Extract the HTTP status code (last line) and body (everything else)
      HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
      BODY=$(echo "$RESPONSE" | sed '$d')

      # Print debugging information
      echo "HTTP Status Code: $HTTP_CODE"
      echo "Response Body: $BODY"

      if [ "$HTTP_CODE" -eq 200 ]; then
        echo "✅ Request successfully sent to webhook"

        # Store response in GitHub environment for later extraction
        echo "response=$BODY" >> $GITHUB_ENV
      else
        echo "❌ Failed to send request to webhook. HTTP status code: $HTTP_CODE"
        exit 1
      fi

  - name: Extract Assessment and Reason
    shell: bash
    run: |
      # Extract `body` JSON string
      BODY_JSON='${{ fromJSON(env.response).body }}'

      # Store parsed JSON in environment variables
      echo "assessment=${{ fromJSON(BODY_JSON).assessment }}" >> $GITHUB_ENV
      echo "reason=${{ fromJSON(BODY_JSON).reason }}" >> $GITHUB_ENV

      echo "Assessment: ${{ fromJSON(BODY_JSON).assessment }}"
      echo "Reason: ${{ fromJSON(BODY_JSON).reason }}"
